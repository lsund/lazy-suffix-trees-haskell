* History
** Wiener in 1973 developed the first suffix tree algorithm
** McCreight a few years later developed a more space efficient solution
** Ukkonen developed in the 90's an algorithm with all the advantages of McCreight, but simpler to understand
* General
** Expresses the internal structure of a string in a much deeper level than ordinary preprocessing
** Solves the exact linear matching problem in linear time with the same worst case bound as KNP
** Real value though, comes from linear use to many string problems more complex than exact matching
** Provides a bridge between exact and approximate matching
** Classic application of suffix trees:
*** Preprocess in O(m)
*** Search in O(n)
** For each P, you do not need to preprocess the text again.
** KNP Needs O(m) for each new string
** Suffix trees has not made it in the mainstream, maybe because the papers are hard to understand.
** It's unfortunate, since the algorithm arn't that complicated
** When implemented well, they can efficiently solve many complex string problems.
** No single other data-structure can act as a solution to that many problems that easily.
** Generalized Suffix trees
  Building a suffix tree for a single string can easily be extended to
  building a suffix tree for a set of strings.
*** Method 1
 1. Append a unique string marker ($) to each string in the set.
 2. concatenate all strings together
 3. Build a suffix tree of the concatenated string
 4. The leaf markers are now numbers denoting starting
    positions. Since we know the positions of all $'s these numbers
    can easily be converted to a tuple (i,j) where i is the string
    index and j is the suffix starting position in string i.
*** Method 2
   Method 1 generates substrings that span more than the original
   strings. These 'synthetic' suffixes are not of interest.

 1. First build a suffix tree of S1.
 2. Starting at the root of this tree, match S2 against the path in
    the tree until mismatch.
 3. Suppose that the first i characters of S2 match. Then the tree
    encodes every suffix of S2[1..i].
 4. Resume Ukkonen's algorithm on S2 in phase i + 1.
 5. Mark leaves with the string accordingly

* Notations
** T     : Text, the searchspace. Length m.
** S     : String, the search string to be found in T. Length n.
** P     : Pattern, same as string but usually used when there are many.
** SET_P : Same as P but seen as a set.
* Definitions
** Alphabet is assumed finite and known
** A suffix tree for an m-character string S properties
*** rooted, directed tree
*** exactly m leaves numbered 1 to m
*** Each internal node other than the root has at least 2 children
*** Each edge is labeled with a non-empty substring of S
*** No two edges of a node can have edge-labels beginning with the same character
*** The key feature is that for each leaf i, the root->leaf label spells out the suffix starting at i in S
*** Thus, for each internal node v, all numbers of the leafs under v corresponds to the starting indices of the root->node label (string).
** Problem:
*** Statement
    If one suffix matches a prefix of another suffix then it's not
    possible to create such a suffix tree, since the path for the
    first suffx would not end in a leaf.
*** Solution:
    Assume that the last character of S does not occur anywhere else
    in S. (can append a special character to S).
** The label of a root->node path is the concatination of substrings of the edges in the correct order
** For any node v, the string depth is the number of characters in v's label
** A path that ends in a middle of an edge splits the label at the designated point.
** Suffix Links
   Let xa denote an arbitrary string where x is a single character and
   a is a substring. For an internal node v with path label xa, if
   there is another node s(v) with path-label a, then the pointer from
   v to s(v) is called a suffix link.

* Applications
** Notes
*** Some of these applications need an additional tool: The constant time lowest common ancestor algorithm
** APL1: Exact string matching
   Note that if only one occurence of P in T suffices, then this can
   be queried in O(n) rather than O(n + k). The idea is to in every
   node store one index of its leafs. This can be achieved in O(n) in
   preprocessing by Depth first traversal.
*** Variant 1: A single T and a single S.
    Suffix trees in this case acheives the same bound O(m + n) like KNP.
*** Variant 2: A single T and multiple P.
    For each of the patterns P, all occurences of P must be found in T
    fast.  For suffix trees, this can be done in O(n + k) where k is
    the number of occurences of P in T. In contrast, KNP etc need
    O(n + m) for every single P.
*** Variant 3: Multiple T and a single S.
    KNP etc spend O(n) for each S. Allthough not obvious, suffix trees
    can achieve the same bound. But their superiority lies in
    variant 2.

** APL2: Exact set matching
   Finding all occurences of a set SET_P in T. Aho-Corasick method
   finds all occurences in O(n + m + k). The same bound is easily
   achieved by suffix trees. And of course, when there might be
   multiple SET_P's we get the same advantages as in APL1. To solve
   the set matching problem, just build a suffix tree for T and query
   it for every element in SET_P.
*** Comparison of suffix trees and keyword trees for exact matching
    | method       | size | build time | search time |
    |              |      |            |             |
    | Aho-Corasick | O(n) | O(n)       | O(m)        |
    | suffix tree  | O(m) | O(m)       | O(n)        |
** APL3: Substring problem for a database of patterns
   Given a set of strings, (a database) find for each presented string S
   all strings in the database containing S. If you have a long
   string, you could look at it like a database of strings if you keep
   the indices.
*** The combined length of all strings in the database is m.
*** Can build tree in O(m)
*** Any string can be determined in/not in the database in O(n).
    If the full string is in the database then the matching path
    reaches a leaf at the same time that the last character of a
    string S is considered. Moreover, if S is a substring of some of
    the strings in the database, then all of those strings can be found in O(n + k) time.
** APL4: Longest common substring for two strings
*** OBS: Not subsequence
*** Method:
    Creata a generalized suffix tree for S1 and S2. Mark each internal
    node v with 1 (2) if there exists a leaf in the subtree of v
    representing a suffix from S1 (S2). The path-label of any node
    marked with both 1 and 2 is a common substring. Now you just have
    to find the one with the greatest string-depth.
*** Construction: O(|S1| + |S2|)
*** Markings + string depth: standard linear tree traversal methods.
** APL5: Recognizing DNA contamination
   Contamination in DNA can come from many different sources.
*** Bacteria/yest
*** Foreign DNA
*** ...
    Often, the sources (strings of DNA) of possible contaminants are
    known. This motivates solving the following problem.

    DNA contamination problem: Given a string S1 (the newly isolated
    and sequenced string of DNA) and a known string S2 (the combined
    sources of possible contamination), find all substrings of S2 that
    occur in S1 and that are longer than some input length L.

    These substrings are candidates for unwanted pieces of S2 that have
    contaminated S1.

    The problem can easily be solved in linear time by extending the
    approach discussed in APL4. Build a generalized suffix tree for S1
    and S2. Then mark each internal node that has in its subtree a
    leaf representing a suffix of S1 and also a leaf representing a
    suffix of S2. Finally, report all marked nodes that have a
    string-depth of L or greater. If v is such ha marked node, then
    the path-label of v is a suspicious string.

    More generally, you might have a set of known DNA string
    contamination sources. Here, you can build a generalized suffix
    tree for the SET_P of possible contaminants together with S1 and
    mark every internal node that has a leaf in its subtree
    representing a suffix from S1 and a leaf representing a suffix
    from a pattern in SET_P.
** APL6: Common substrings of more than two strings
   Important in biology in many different contexts.

   Given a set of strings find substring common to a large number of
   those strings.

   Suppose we have K strings whose lengths sum to n.

   For each k between 2 and K, we define l(k) to be th elength of the
   longest substring common to at least k of the strings.
   We want to compute a table of K - 1 entries, where entry k gives
   l(k) and also points to one of the common substrings of that
   length. For example, consider {sanddollar, sandlot, handler, grand,
   pandtry}. Then the table becomes

   | k | l(k) | one substring |
   |---+------+---------------|
   | 2 |    4 | sand          |
   | 3 |    3 | and           |
   | 4 |    3 | and           |
   | 5 |    2 | an            |
   |---+------+---------------|

   This can be solved in linear O(n) time. The linear time algorithm
   is fully discussed in chapter 9 after the lowest common ancestor
   method has been discussed.

   Now we show how to solve this in O(Kn). This is acheived by the
   generalization of the longest common substring method for two
   strings.
   1. Build a generalized suffix tree T for the K strings.
   2. Each leaf then represents a suffix from one of the K strings and
      is marked with one of the K unique string identifiers.
   3. Each of the K strings has a distinct termination symbol, so that
      identical suffixes will be at different leaves in the
      generalized suffix tree -> each leaf in T has exactly one string
      identifier.
   4. Define C(v) to be the number of distict string identifiers that
      appears in the leaves of some inner node v.
      If all C(v) values are known, and the string depth of every node
      is known, all l(k) can be extracted with an easy tree-traversal.

   Computing C(v):
   Given an internal node v, it's easy to compute the number of leaves
   in the subtree in linear time. (Tree traversal). But this number
   might be much larger than C(v) because two leaves in the subtree
   might have the same identifier. For the moment, we take the easy
   way and explicitly count for each inner node, and each of the K
   strings. The resulting time is O(Kn).
   Method. For each inner node v: create a K-length boolean array A and
   set A[i] = true if there is a leaf with identifier i in the subtree. Then
   C(v) is just the number of true values in that vector.
** APL7: Building a smaller directed graph for exact matching
   In many applications space is the critical constraint. Now we show
   how to compress a suffix tree into a directed acyclic graph (DAG),
   that can be sed to solve APL1 (and others) but take less space. The
   method can also be used to build a directed acyclic word graph
   (DAWG) which is the smallest finite-state machine that can
   recognize suffixes of a given string.

   For a given suffix tree, it might be the case that one subtree is
   isomorphic with another subtree. That is, for every path in one of
   the subtrees, there is a path in the other subtree with the same
   label. In that case, one might remove one subtree and connect the
   "dangling" edges to the root node of the second subtree. This is now
   a DAG, not a tree which is smaller than the initial suffix
   tree. It also solves the string matching problem for any given
   pattern, but the leaves does not necessarily give the correct
   starting positions anymore. Possible to fix? Exercise 10.

   Detecting isomorphism:
   Theorem: Two subtrees below p and q are isomorphic iff:
   1. there is a directed path of suffix links from one node to the
      other.
   2. The number of leaves in the two subtrees are equal.
   Proof:
   Assume that there is a direct suffix link from p to q. Since there
   is a suffix link from p to q, p has a path label xa while q has
   path-label a. Thus, for every leaf in the subtree of p with index i
   there exists a leaf in the subtree of q with index i + 1. All these
   indices represent the same suffix exept that the lower ones start
   with xa and the greater with a. Since the label up to p in denoted
   by xa and up to q is denoted by a, any path in one tree also exists
   in the other tree. By the same reasoning, this is true also for a
   sequence of suffix pointers.
* Ideas:
** Suffix trees on infinite strings
*** Could first create suffix tree up to N characters and then lazily build STree
*** Really inefficient?
** Suffix trees related to functional programming
** Should be very easy to parallelize in the functional paradigm
** Investigate higher level functional concepts for local update
