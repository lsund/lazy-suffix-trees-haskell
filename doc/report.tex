\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{float}

\title{Master Thesis}

\author{Ludvig Sundstr\"{o}m}
\date{\today}

\begin{document}

\maketitle

\section{General}

Suffix trees exposes the internal structure of a string on a deep level. This
suprisingly simple datastructure allows for solving a wide range of problems
efficiently and easily. While algorithms such as Knuth-Morris-Pratt (KMP)
algorithm~\cite{website:knp-wiki} or the Boyer-Moore algorithm (BM)
~\cite{website:bm-wiki} desrcibes in a traditional manner a specific sequence of
steps to solve a specific problem, suffix trees are just data, and can be
applied to many different string problems. Many of those are more complex than
exact string search that KMP and BM solves. Even so, it should be mentioned that
Suffix trees achieves the same time complexity bound for exact string search as
these algorithms. In addition, in some settings of exact string search suffix
trees are vastly superior.

\section{Notation and Definitions}

A string is $S$ is an ordered list of characters written contiguously from left
to right. For any string S, S[i..j] is the substring of S that starts at
position $i$ and ends at position $j$. In particular, S[1..i] is the prefix that
ends at position $i$ and $S[j..|S|]$ is the suffux of $S$ that starts at
position $j$. We call a prefix, suffix or substring of S \textit{proper} if it is not
the entire string. For any string S, $S(i)$ denotes the i'th character of S. We
say that two characters $a$ and $b$ \textit{match} if $a = b$ , and
\textit{mismatch} otherwise. We consider two strings equal if $|S| = |T|$
of equal length and $\{ S(i) = T(i) | i \in [1..|S|]\}$. In that case, we also
say that the two strings \textit{matches}.
\\
We'll usually use $T$ to denote the search space and will be refered to as ``a
text''. $S$ is the search string and will be referred to as ``a string''. In the
case of the string search problem, we want to find $S$ as a substring of
$T$. Both $T$ and $S$ are strings and Usually $|T| >> |S|$.

\section{Use cases and Applications}

\subsection{Exact String Search}

There are three variants of this problem.
\begin{enumerate}
        \item A single text and a single string is presented, at the same time.
        \item A single text is presented first and then multiple strings.
        \item A single string is presented first and then multiple texts.
\end{enumerate}

TODO FROM HERE
\\
A typical use case where they excel other string searching algorithms is when
you have one pice of text, fixed over some time, but are presented multiple
pattern strings. The task is now to find all occurences of each pattern in the
text. With suffix trees, you need $O(n + k)$ for each pattern. In contrast, KMP
and BM needs $O(m + n)$ for each input string presented.

\section{History}

\medskip

\bibliography{report}
\bibliographystyle{plain}

\end{document}
